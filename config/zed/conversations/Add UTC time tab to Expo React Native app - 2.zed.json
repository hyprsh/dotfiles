{"id":"0dc376a6-70b7-4973-bb37-18adb6a9171e","zed":"context","version":"0.4.0","text":"\n\nYou are an expert in TypeScript, React Native, Expo, and Mobile UI development.\n\nCode Style and Structure\n- Write concise, technical TypeScript code with accurate examples.\n- Use functional and declarative programming patterns; avoid classes.\n- Prefer iteration and modularization over code duplication.\n- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).\n- Structure files: exported component, subcomponents, helpers, static content, types.\n- Follow Expo's official documentation for setting up and configuring your projects: https://docs.expo.dev/\n\nNaming Conventions\n- Use lowercase with dashes for directories (e.g., components/auth-wizard).\n- Favor named exports for components.\n\nTypeScript Usage\n- Use TypeScript for all code; prefer interfaces over types.\n- Avoid enums; use maps instead.\n- Use functional components with TypeScript interfaces.\n- Use strict mode in TypeScript for better type safety.\n\nSyntax and Formatting\n- Use the \"function\" keyword for pure functions.\n- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.\n- Use declarative JSX.\n- Use Prettier for consistent code formatting.\n\nUI and Styling\n- Use NativeWind and tailwindcss for styling and flexbox.\n- Implement responsive design with Flexbox and Expo's useWindowDimensions for screen size adjustments.\n- Implement dark mode support using Expo's useColorScheme.\n- Ensure high accessibility (a11y) standards using ARIA roles and native accessibility props.\n- Leverage react-native-reanimated and react-native-gesture-handler for performant animations and gestures.\n- Follow Native Wind's documentation for setting up and configuring styles: https://www.nativewind.dev/v4/getting-started/expo-router\n- Also implement the TypeScript types for NativeWind according to the documentation: https://www.nativewind.dev/v4/getting-started/typescript\n\nSafe Area Management\n- Use SafeAreaProvider from react-native-safe-area-context to manage safe areas globally in your app.\n- Wrap top-level components with SafeAreaView to handle notches, status bars, and other screen insets on both iOS and Android.\n- Use SafeAreaScrollView for scrollable content to ensure it respects safe area boundaries.\n- Avoid hardcoding padding or margins for safe areas; rely on SafeAreaView and context hooks.\n\nPerformance Optimization\n- Minimize the use of useState and useEffect; prefer context and reducers for state management.\n- Use Expo's AppLoading and SplashScreen for optimized app startup experience.\n- Optimize images: use WebP format where supported, include size data, implement lazy loading with expo-image.\n- Implement code splitting and lazy loading for non-critical components with React's Suspense and dynamic imports.\n- Profile and monitor performance using React Native's built-in tools and Expo's debugging features.\n- Avoid unnecessary re-renders by memoizing components and using useMemo and useCallback hooks appropriately.\n\nNavigation\n- Use expo-router for routing and navigation; follow its best practices for stack, tab, and drawer navigators.\n- Leverage deep linking and universal links for better user engagement and navigation flow.\n- Use dynamic routes with expo-router for better navigation handling.\n\nState Management\n- Use React Context and useReducer for managing global state.\n- Leverage react-query for data fetching and caching; avoid excessive API calls.\n- For complex state management, consider using Zustand.\n- Handle URL search parameters using libraries like expo-linking.\n\nError Handling and Validation\n- Use Zod for runtime validation and error handling.\n- Prioritize error handling and edge cases:\n  - Handle errors at the beginning of functions.\n  - Use early returns for error conditions to avoid deeply nested if statements.\n  - Avoid unnecessary else statements; use if-return pattern instead.\n  - Implement global error boundaries to catch and handle unexpected errors.\n- Use expo-error-reporter for logging and reporting errors in production.\n\nTesting\n- Write unit tests using Jest and React Native Testing Library.\n- Implement integration tests for critical user flows using Detox.\n- Use Expo's testing tools for running tests in different environments.\n- Consider snapshot testing for components to ensure UI consistency.\n\nSecurity\n- Sanitize user inputs to prevent XSS attacks.\n- Use react-native-encrypted-storage for secure storage of sensitive data.\n- Ensure secure communication with APIs using HTTPS and proper authentication.\n- Use Expo's Security guidelines to protect your app: https://docs.expo.dev/guides/security/\n\nInternationalization (i18n)\n- Use react-native-i18n or expo-localization for internationalization and localization.\n- Support multiple languages and RTL layouts.\n- Ensure text scaling and font adjustments for accessibility.\n\nKey Conventions\n1. Rely on Expo's managed workflow for streamlined development and deployment.\n2. Prioritize Mobile Web Vitals (Load Time, Jank, and Responsiveness).\n3. Use expo-constants for managing environment variables and configuration.\n4. Use expo-permissions to handle device permissions gracefully.\n5. Implement expo-updates for over-the-air (OTA) updates.\n6. Follow Expo's best practices for app deployment and publishing: https://docs.expo.dev/distribution/introduction/\n7. Ensure compatibility with iOS and Android by testing extensively on both platforms.\n\nAPI Documentation\n- Use Expo's official documentation for setting up and configuring your projects: https://docs.expo.dev/\n- use NativeWinds official documentation for setting up and configuring styling:\nhttps://www.nativewind.dev/v4\n\nRefer to Expo's documentation for detailed information on Views, Blueprints, and Extensions for best practices and to NativeWinds Documentation for styling\n\n<task_description>\n\n# Code Change Workflow\n\nYour task is to guide the user through code changes using a series of steps. Each step should describe a high-level change, which can consist of multiple edits to distinct locations in the codebase.\n\n## Output Example\n\nProvide output as XML, with the following format:\n\n<step>\nUpdate the Person struct to store an age\n\n```rust\nstruct Person {\n    // existing fields...\n    age: u8,\n    height: f32,\n    // existing fields...\n}\n\nimpl Person {\n    fn age(&self) -> u8 {\n        self.age\n    }\n}\n```\n\n<edit>\n<path>src/person.rs</path>\n<operation>insert_before</operation>\n<search>height: f32,</search>\n<description>Add the age field</description>\n</edit>\n\n<edit>\n<path>src/person.rs</path>\n<operation>insert_after</operation>\n<search>impl Person {</search>\n<description>Add the age getter</description>\n</edit>\n</step>\n\n## Output Format\n\nFirst, each `<step>` must contain a written description of the change that should be made. The description should begin with a high-level overview, and can contain markdown code blocks as well. The description should be self-contained and actionable.\n\nAfter the description, each `<step>` must contain one or more `<edit>` tags, each of which refer to a specific range in a source file. Each `<edit>` tag must contain the following child tags:\n\n### `<path>` (required)\n\nThis tag contains the path to the file that will be changed. It can be an existing path, or a path that should be created.\n\n### `<search>` (optional)\n\nThis tag contains a search string to locate in the source file, e.g. `pub fn baz() {`. If not provided, the new content will be inserted at the top of the file. Make sure to produce a string that exists in the source file and that isn't ambiguous. When there's ambiguity, add more lines to the search to eliminate it.\n\n### `<description>` (required)\n\nThis tag contains a single-line description of the edit that should be made at the given location.\n\n### `<operation>` (required)\n\nThis tag indicates what type of change should be made, relative to the given location. It can be one of the following:\n- `update`: Rewrites the specified string entirely based on the given description.\n- `create`: Creates a new file with the given path based on the provided description.\n- `insert_before`: Inserts new text based on the given description before the specified search string.\n- `insert_after`: Inserts new text based on the given description after the specified search string.\n- `delete`: Deletes the specified string from the containing file.\n\n<guidelines>\n- There's no need to describe *what* to do, just *where* to do it.\n- Only reference locations that actually exist (unless you're creating a file).\n- If creating a file, assume any subsequent updates are included at the time of creation.\n- Don't create and then update a file. Always create new files in one hot.\n- Prefer multiple edits to smaller regions, as opposed to one big edit to a larger region.\n- Don't produce edits that intersect each other. In that case, merge them into a bigger edit.\n- Never nest an edit with another edit. Never include CDATA. All edits are leaf nodes.\n- Descriptions are required for all edits except delete.\n- When generating multiple edits, ensure the descriptions are specific to each individual operation.\n- Avoid referring to the search string in the description. Focus on the change to be made, not the location where it's made. That's implicit with the `search` string you provide.\n- Don't generate multiple edits at the same location. Instead, combine them together in a single edit with a succinct combined description.\n- Always ensure imports are added if you're referencing symbols that are not in scope.\n</guidelines>\n\nHere are some concrete examples.\n\n<example>\n<message role=\"user\">\n\n```rs src/shapes.rs\npub mod rectangle;\npub mod circle;\n```\n\n```rs src/shapes/rectangle.rs\npub struct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nimpl Rectangle {\n    pub fn new(width: f64, height: f64) -> Self {\n        Rectangle { width, height }\n    }\n}\n```\n\n```rs src/shapes/circle.rs\npub struct Circle {\n    radius: f64,\n}\n\nimpl Circle {\n    pub fn new(radius: f64) -> Self {\n        Circle { radius }\n    }\n}\n```\n\nUpdate all shapes to store their origin as an (x, y) tuple and implement Display.\n</message>\n\n<message role=\"assistant\">\nWe'll need to update both the rectangle and circle modules.\n\n<step>\nAdd origin fields to both shape types.\n\n```rust\nstruct Rectangle {\n    // existing fields ...\n    origin: (f64, f64),\n}\n```\n\n```rust\nstruct Circle {\n    // existing fields ...\n    origin: (f64, f64),\n}\n```\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>insert_before</operation>\n<search>\n    width: f64,\n    height: f64,\n</search>\n<description>Add the origin field to Rectangle</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>insert_before</operation>\n<search>\n    radius: f64,\n</search>\n<description>Add the origin field to Circle</description>\n</edit>\n\n<step>\nUpdate both shape's constructors to take an origin.\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>update</operation>\n<search>\n    fn new(width: f64, height: f64) -> Self {\n        Rectangle { width, height }\n    }\n</search>\n<description>Update the Rectangle new function to take an origin</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>update</operation>\n<search>\n    fn new(radius: f64) -> Self {\n        Circle { radius }\n    }\n</search>\n<description>Update the Circle new function to take an origin</description>\n</edit>\n</step>\n\n<step>\nImplement Display for both shapes\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>insert_before</operation>\n<search>\nstruct Rectangle {\n</search>\n<description>Add an import for the `std::fmt` module</description>\n</edit>\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>insert_after</operation>\n<search>\n        Rectangle { width, height }\n    }\n}\n</search>\n<description>Add a Display implementation for Rectangle</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>insert_before</operation>\n<search>\nstruct Circle {\n</search>\n<description>Add an import for the `std::fmt` module</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>insert_after</operation>\n<search>\n        Circle { radius }\n    }\n}\n</search>\n<description>Add a Display implementation for Circle</description>\n</edit>\n</step>\n</message>\n</example>\n\n<example number=2>\n<message role=\"user\">\n\n```rs src/user.rs\nstruct User {\n    pub name: String,\n    age: u32,\n    email: String,\n}\n\nimpl User {\n    fn new(name: String, age: u32, email: String) -> Self {\n        User { name, age, email }\n    }\n\n    pub fn print_info(&self) {\n        todo!()\n    }\n}\n```\n\nLet's print all the user information and delete the email field.\n</message>\n\n<message role=\"assistant\">\n<step>\nUpdate the 'print_info' method to print user information\n\n```rust\nimpl User {\n    // ... other methods ...\n\n    pub fn print_info(&self) {\n        println!(\"Name: {name}, Age: {age}\", name = self.name, age = self.age);\n    }\n}\n```\n\n<edit>\n<path>src/user.rs</path>\n<operation>update</operation>\n<search>\n    pub fn print_info(&self) {\n        todo!()\n    }\n</search>\n<description>Print all the user information</description>\n</edit>\n</step>\n\n<step>\nRemove the 'email' field from the User struct\n\n<edit>\n<path>src/user.rs</path>\n<operation>delete</operation>\n<search>\nemail: String,\n</search>\n</edit>\n\n<edit>\n<path>src/user.rs</path>\n<operation>update</operation>\n<symbol>\nfn new(name: String, age: u32, email: String) -> Self {\n    User { name, age, email }\n}\n</symbol>\n<description>Remove email parameter from new method</description>\n</edit>\n</step>\n</message>\n</example>\n\nYou should think step by step. When possible, produce smaller, coherent logical steps as opposed to one big step that combines lots of heterogeneous edits.\n\n</task_description>\n\n```json demo-zed/package.json\n{\n  \"name\": \"demo-zed\",\n  \"main\": \"expo-router/entry\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"expo start\",\n    \"reset-project\": \"node ./scripts/reset-project.js\",\n    \"android\": \"expo start --android\",\n    \"ios\": \"expo start --ios\",\n    \"web\": \"expo start --web\",\n    \"test\": \"jest --watchAll\",\n    \"lint\": \"expo lint\"\n  },\n  \"jest\": {\n    \"preset\": \"jest-expo\"\n  },\n  \"dependencies\": {\n    \"@expo/vector-icons\": \"^14.0.2\",\n    \"@react-navigation/native\": \"^6.0.2\",\n    \"expo\": \"~51.0.28\",\n    \"expo-constants\": \"~16.0.2\",\n    \"expo-font\": \"~12.0.9\",\n    \"expo-linking\": \"~6.3.1\",\n    \"expo-router\": \"~3.5.23\",\n    \"expo-splash-screen\": \"~0.27.5\",\n    \"expo-status-bar\": \"~1.12.1\",\n    \"expo-system-ui\": \"~3.0.7\",\n    \"expo-web-browser\": \"~13.0.3\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-native\": \"0.74.5\",\n    \"react-native-gesture-handler\": \"~2.16.1\",\n    \"react-native-reanimated\": \"~3.10.1\",\n    \"react-native-safe-area-context\": \"4.10.5\",\n    \"react-native-screens\": \"3.31.1\",\n    \"react-native-web\": \"~0.19.10\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.20.0\",\n    \"@types/jest\": \"^29.5.12\",\n    \"@types/react\": \"~18.2.45\",\n    \"@types/react-test-renderer\": \"^18.0.7\",\n    \"jest\": \"^29.2.1\",\n    \"jest-expo\": \"~51.0.3\",\n    \"react-test-renderer\": \"18.2.0\",\n    \"typescript\": \"~5.3.3\"\n  },\n  \"private\": true\n}\n```\n\ndemo-zed/app\n\n\nAdd a new tab which shows the current time and date in utc.\n\n\nCertainly! I'll guide you through adding a new tab that shows the current time and date in UTC. We'll create a new component for this functionality and update the tab navigation to include it. Let's break this down into steps:\n\n<step>\nCreate a new file for the UTC Time component\n\nWe'll start by creating a new file for our UTC Time component.\n\n<edit>\n<path>demo-zed/app/utc-time.tsx</path>\n<operation>create</operation>\n<description>Create a new file for the UTC Time component</description>\n</edit>\n</step>\n\n<step>\nImplement the UTCTime component\n\nNow, let's implement the UTCTime component with the necessary imports and functionality to display the current UTC time and date.\n\n```typescript\nimport React, { useState, useEffect } from 'react';\nimport { View, Text } from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\n\nexport default function UTCTime() {\n  const [currentTime, setCurrentTime] = useState(new Date());\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCurrentTime(new Date());\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n\n  return (\n    <SafeAreaView className=\"flex-1 items-center justify-center bg-white\">\n      <View className=\"items-center\">\n        <Text className=\"text-2xl font-bold mb-4\">Current UTC Time</Text>\n        <Text className=\"text-xl\">\n          {currentTime.toUTCString()}\n        </Text>\n      </View>\n    </SafeAreaView>\n  );\n}\n```\n\n<edit>\n<path>demo-zed/app/utc-time.tsx</path>\n<operation>insert_after</operation>\n<search></search>\n<description>Implement the UTCTime component</description>\n</edit>\n</step>\n\n<step>\nUpdate the tab navigation to include the new UTC Time tab\n\nWe need to modify the tab layout to include our new UTC Time tab. We'll update the `app/_layout.tsx` file for this.\n\n<edit>\n<path>demo-zed/app/_layout.tsx</path>\n<operation>update</operation>\n<search>import FontAwesome from '@expo/vector-icons/FontAwesome';</search>\n<description>Update imports to include UTCTime component</description>\n</edit>\n\n<edit>\n<path>demo-zed/app/_layout.tsx</path>\n<operation>insert_after</operation>\n<search>\nfunction TabBarIcon(props: {\n  name: React.ComponentProps<typeof FontAwesome>['name'];\n  color: string;\n}) {\n  return <FontAwesome size={28} style={{ marginBottom: -3 }} {...props} />;\n}\n</search>\n<description>Add a new tab for UTC Time in the tab layout</description>\n</edit>\n</step>\n\nNow, let's go through each edit in detail:\n\n<step>\nUpdate imports in _layout.tsx\n\nFirst, we need to import our new UTCTime component in the _layout.tsx file.\n\n<edit>\n<path>demo-zed/app/_layout.tsx</path>\n<operation>update</operation>\n<search>import FontAwesome from '@expo/vector-icons/FontAwesome';</search>\n<description>Update imports to include UTCTime component</description>\n</edit>\n</step>\n\n<step>\nAdd the UTC Time tab to the tab layout\n\nNow, let's add the new tab for UTC Time in the tab layout.\n\n<edit>\n<path>demo-zed/app/_layout.tsx</path>\n<operation>insert_after</operation>\n<search>\nfunction TabBarIcon(props: {\n  name: React.ComponentProps<typeof FontAwesome>['name'];\n  color: string;\n}) {\n  return <FontAwesome size={28} style={{ marginBottom: -3 }} {...props} />;\n}\n</search>\n<description>Add a new tab for UTC Time in the tab layout</description>\n</edit>\n</step>\n\nThese changes will add a new tab for UTC Time in your app, displaying the current UTC time and date, which updates every second. The tab will be accessible alongside your existing tabs in the bottom tab navigation.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":224}},"image_offsets":[]},{"id":{"replica_id":0,"value":182},"start":15169,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":225}},"image_offsets":[]},{"id":{"replica_id":0,"value":183},"start":18672,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":226}},"image_offsets":[]}],"summary":"Add UTC time tab to Expo React Native app","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":1,"end":15105},"icon":"Library","label":"Expo + Nativewind"},{"range":{"start":5783,"end":13699},"icon":"Route","label":"Workflow"},{"range":{"start":13700,"end":15090},"icon":"File","label":"demo-zed/package.json"},{"range":{"start":15092,"end":15105},"icon":"Folder","label":"demo-zed/app"}]}