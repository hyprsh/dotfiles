{"id":"3bf188b1-0b16-46ef-96cd-f6bcc76db7bc","zed":"context","version":"0.4.0","text":"\n\n\n<task_description>\n\n# Code Change Workflow\n\nYour task is to guide the user through code changes using a series of steps. Each step should describe a high-level change, which can consist of multiple edits to distinct locations in the codebase.\n\n## Output Example\n\nProvide output as XML, with the following format:\n\n<step>\nUpdate the Person struct to store an age\n\n```rust\nstruct Person {\n    // existing fields...\n    age: u8,\n    height: f32,\n    // existing fields...\n}\n\nimpl Person {\n    fn age(&self) -> u8 {\n        self.age\n    }\n}\n```\n\n<edit>\n<path>src/person.rs</path>\n<operation>insert_before</operation>\n<search>height: f32,</search>\n<description>Add the age field</description>\n</edit>\n\n<edit>\n<path>src/person.rs</path>\n<operation>insert_after</operation>\n<search>impl Person {</search>\n<description>Add the age getter</description>\n</edit>\n</step>\n\n## Output Format\n\nFirst, each `<step>` must contain a written description of the change that should be made. The description should begin with a high-level overview, and can contain markdown code blocks as well. The description should be self-contained and actionable.\n\nAfter the description, each `<step>` must contain one or more `<edit>` tags, each of which refer to a specific range in a source file. Each `<edit>` tag must contain the following child tags:\n\n### `<path>` (required)\n\nThis tag contains the path to the file that will be changed. It can be an existing path, or a path that should be created.\n\n### `<search>` (optional)\n\nThis tag contains a search string to locate in the source file, e.g. `pub fn baz() {`. If not provided, the new content will be inserted at the top of the file. Make sure to produce a string that exists in the source file and that isn't ambiguous. When there's ambiguity, add more lines to the search to eliminate it.\n\n### `<description>` (required)\n\nThis tag contains a single-line description of the edit that should be made at the given location.\n\n### `<operation>` (required)\n\nThis tag indicates what type of change should be made, relative to the given location. It can be one of the following:\n- `update`: Rewrites the specified string entirely based on the given description.\n- `create`: Creates a new file with the given path based on the provided description.\n- `insert_before`: Inserts new text based on the given description before the specified search string.\n- `insert_after`: Inserts new text based on the given description after the specified search string.\n- `delete`: Deletes the specified string from the containing file.\n\n<guidelines>\n- There's no need to describe *what* to do, just *where* to do it.\n- Only reference locations that actually exist (unless you're creating a file).\n- If creating a file, assume any subsequent updates are included at the time of creation.\n- Don't create and then update a file. Always create new files in one hot.\n- Prefer multiple edits to smaller regions, as opposed to one big edit to a larger region.\n- Don't produce edits that intersect each other. In that case, merge them into a bigger edit.\n- Never nest an edit with another edit. Never include CDATA. All edits are leaf nodes.\n- Descriptions are required for all edits except delete.\n- When generating multiple edits, ensure the descriptions are specific to each individual operation.\n- Avoid referring to the search string in the description. Focus on the change to be made, not the location where it's made. That's implicit with the `search` string you provide.\n- Don't generate multiple edits at the same location. Instead, combine them together in a single edit with a succinct combined description.\n- Always ensure imports are added if you're referencing symbols that are not in scope.\n</guidelines>\n\nHere are some concrete examples.\n\n<example>\n<message role=\"user\">\n\n```rs src/shapes.rs\npub mod rectangle;\npub mod circle;\n```\n\n```rs src/shapes/rectangle.rs\npub struct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nimpl Rectangle {\n    pub fn new(width: f64, height: f64) -> Self {\n        Rectangle { width, height }\n    }\n}\n```\n\n```rs src/shapes/circle.rs\npub struct Circle {\n    radius: f64,\n}\n\nimpl Circle {\n    pub fn new(radius: f64) -> Self {\n        Circle { radius }\n    }\n}\n```\n\nUpdate all shapes to store their origin as an (x, y) tuple and implement Display.\n</message>\n\n<message role=\"assistant\">\nWe'll need to update both the rectangle and circle modules.\n\n<step>\nAdd origin fields to both shape types.\n\n```rust\nstruct Rectangle {\n    // existing fields ...\n    origin: (f64, f64),\n}\n```\n\n```rust\nstruct Circle {\n    // existing fields ...\n    origin: (f64, f64),\n}\n```\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>insert_before</operation>\n<search>\n    width: f64,\n    height: f64,\n</search>\n<description>Add the origin field to Rectangle</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>insert_before</operation>\n<search>\n    radius: f64,\n</search>\n<description>Add the origin field to Circle</description>\n</edit>\n\n<step>\nUpdate both shape's constructors to take an origin.\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>update</operation>\n<search>\n    fn new(width: f64, height: f64) -> Self {\n        Rectangle { width, height }\n    }\n</search>\n<description>Update the Rectangle new function to take an origin</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>update</operation>\n<search>\n    fn new(radius: f64) -> Self {\n        Circle { radius }\n    }\n</search>\n<description>Update the Circle new function to take an origin</description>\n</edit>\n</step>\n\n<step>\nImplement Display for both shapes\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>insert_before</operation>\n<search>\nstruct Rectangle {\n</search>\n<description>Add an import for the `std::fmt` module</description>\n</edit>\n\n<edit>\n<path>src/shapes/rectangle.rs</path>\n<operation>insert_after</operation>\n<search>\n        Rectangle { width, height }\n    }\n}\n</search>\n<description>Add a Display implementation for Rectangle</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>insert_before</operation>\n<search>\nstruct Circle {\n</search>\n<description>Add an import for the `std::fmt` module</description>\n</edit>\n\n<edit>\n<path>src/shapes/circle.rs</path>\n<operation>insert_after</operation>\n<search>\n        Circle { radius }\n    }\n}\n</search>\n<description>Add a Display implementation for Circle</description>\n</edit>\n</step>\n</message>\n</example>\n\n<example number=2>\n<message role=\"user\">\n\n```rs src/user.rs\nstruct User {\n    pub name: String,\n    age: u32,\n    email: String,\n}\n\nimpl User {\n    fn new(name: String, age: u32, email: String) -> Self {\n        User { name, age, email }\n    }\n\n    pub fn print_info(&self) {\n        todo!()\n    }\n}\n```\n\nLet's print all the user information and delete the email field.\n</message>\n\n<message role=\"assistant\">\n<step>\nUpdate the 'print_info' method to print user information\n\n```rust\nimpl User {\n    // ... other methods ...\n\n    pub fn print_info(&self) {\n        println!(\"Name: {name}, Age: {age}\", name = self.name, age = self.age);\n    }\n}\n```\n\n<edit>\n<path>src/user.rs</path>\n<operation>update</operation>\n<search>\n    pub fn print_info(&self) {\n        todo!()\n    }\n</search>\n<description>Print all the user information</description>\n</edit>\n</step>\n\n<step>\nRemove the 'email' field from the User struct\n\n<edit>\n<path>src/user.rs</path>\n<operation>delete</operation>\n<search>\nemail: String,\n</search>\n</edit>\n\n<edit>\n<path>src/user.rs</path>\n<operation>update</operation>\n<symbol>\nfn new(name: String, age: u32, email: String) -> Self {\n    User { name, age, email }\n}\n</symbol>\n<description>Remove email parameter from new method</description>\n</edit>\n</step>\n</message>\n</example>\n\nYou should think step by step. When possible, produce smaller, coherent logical steps as opposed to one big step that combines lots of heterogeneous edits.\n\n</task_description>\n\n/add ~/.config/zed/settings.json\nCertainly! I'll guide you through the process of adding a `~/.config/zed/settings.json` file. This will be done in a single step since we're creating a new file with initial content.\n\n<step>\nCreate a new settings.json file for Zed editor\n\nLet's create a new `settings.json` file in the `~/.config/zed/` directory. This file will contain the initial configuration for the Zed editor.\n\n```json\n{\n  \"theme\": \"One Dark\",\n  \"font_family\": \"Menlo\",\n  \"font_size\": 14,\n  \"tab_size\": 2,\n  \"relative_line_numbers\": true,\n  \"soft_wrap\": \"none\",\n  \"auto_update\": true,\n  \"telemetry\": false\n}\n```\n\nThis configuration sets up some basic preferences:\n- Uses the \"One Dark\" theme\n- Sets the font to Menlo with a size of 14\n- Sets the tab size to 2 spaces\n- Enables relative line numbers\n- Disables soft wrapping\n- Enables auto-updates\n- Disables telemetry\n\n<edit>\n<path>~/.config/zed/settings.json</path>\n<operation>create</operation>\n<description>Create initial Zed editor settings file</description>\n</edit>\n</step>\nadd comments to the settings file\nCertainly! I'll add comments to the settings file to explain each option. This will make the configuration more user-friendly and easier to understand.\n\n<step>\nAdd explanatory comments to the Zed settings file\n\nLet's update the `settings.json` file with comments for each setting. This will help users understand what each option does and how to modify it.\n\n```json\n{\n  // The color theme for the editor\n  \"theme\": \"One Dark\",\n\n  // The font family to use in the editor\n  \"font_family\": \"Menlo\",\n\n  // The font size in points\n  \"font_size\": 14,\n\n  // The number of spaces a tab is equal to\n  \"tab_size\": 2,\n\n  // Whether to show relative line numbers\n  \"relative_line_numbers\": true,\n\n  // Controls text wrapping. Options: \"none\", \"editor_width\", or \"window_width\"\n  \"soft_wrap\": \"none\",\n\n  // Whether to automatically check for and install updates\n  \"auto_update\": true,\n\n  // Whether to send anonymous usage data to improve Zed\n  \"telemetry\": false\n}\n```\n\n<edit>\n<path>~/.config/zed/settings.json</path>\n<operation>update</operation>\n<search>{\n  \"theme\": \"One Dark\",\n  \"font_family\": \"Menlo\",\n  \"font_size\": 14,\n  \"tab_size\": 2,\n  \"relative_line_numbers\": true,\n  \"soft_wrap\": \"none\",\n  \"auto_update\": true,\n  \"telemetry\": false\n}</search>\n<description>Add explanatory comments to each setting</description>\n</edit>\n</step>\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":140}},"image_offsets":[]},{"id":{"replica_id":0,"value":21},"start":7953,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":141}},"image_offsets":[]},{"id":{"replica_id":0,"value":22},"start":8956,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":142}},"image_offsets":[]},{"id":{"replica_id":0,"value":85},"start":8990,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":143}},"image_offsets":[]},{"id":{"replica_id":0,"value":86},"start":10316,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":144}},"image_offsets":[]}],"summary":"Certainly! I'll add comments to summarize the context into a short title without punctuation for each setting in the Zed editor's `settings.json` file. Here's the updated step:","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":7919},"icon":"Route","label":"Workflow"}]}